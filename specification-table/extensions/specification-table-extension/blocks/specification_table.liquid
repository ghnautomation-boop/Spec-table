{% comment %}
  Block pentru afișarea tabelului de specificații
  Se conectează la API-ul app-ului pentru a obține template-ul
{% endcomment %}

<link rel="stylesheet" href="{{ 'specification-table.css' | asset_url }}">

{% assign product_id = product.id | default: block.settings.product.id %}
{% comment %}
  Extrage collection_id:
  1. Dacă suntem pe o pagină de colecție → folosim collection.id
  2. Dacă suntem pe o pagină de produs → folosim prima colecție din product.collections
     NOTĂ: Pe paginile de produs, collection.id NU există în context
     Trebuie să folosim product.collections pentru a obține colecțiile
  3. Fallback la block.settings.collection.id
{% endcomment %}
{% assign collection_id = blank %}

{% comment %} Verifică dacă suntem pe o pagină de colecție {% endcomment %}
{% if collection and collection.id %}
  {% assign collection_id = collection.id %}
{% comment %} Verifică dacă suntem pe o pagină de produs și produsul are colecții {% endcomment %}
{% elsif product and product.collections %}
  {% comment %} 
    Pe paginile de produs, collection.id NU există în context
    Trebuie să iterăm prin product.collections pentru a obține prima colecție
    NOTĂ: Folosim collection_item pentru a evita conflictul cu variabila globală collection
  {% endcomment %}
  {% for collection_item in product.collections limit: 1 %}
    {% assign collection_id = collection_item.id %}
  {% endfor %}
{% elsif block.settings.collection and block.settings.collection.id %}
  {% assign collection_id = block.settings.collection.id %}
{% endif %}

{% comment %} Debug: afișează collection_id pentru debugging {% endcomment %}
{% if collection_id != blank %}
  {% comment %} Collection ID found: {{ collection_id }} {% endcomment %}
{% else %}
  {% comment %} No collection ID found {% endcomment %}
{% endif %}
{% assign shop_domain = shop.permanent_domain %}

{% comment %} Container pentru template {% endcomment %}
{% assign max_width = block.settings.max_width | default: 1200 %}
{% assign alignment = block.settings.alignment | default: 'left' %}
{% assign margin_top = block.settings.margin_top | default: 0 %}
{% assign margin_left = block.settings.margin_left | default: 0 %}
{% assign first_column_width = block.settings.first_column_width | default: 40 %}
{% assign image_height = block.settings.image_height | default: 100 %}

<div id="specification-table-container-{{ block.id }}" 
     data-product-id="{{ product_id }}" 
     {% if collection_id != blank %}data-collection-id="{{ collection_id }}"{% endif %}
     data-shop="{{ shop_domain }}"
     data-max-width="{{ max_width }}"
     data-alignment="{{ alignment }}"
     data-margin-top="{{ margin_top }}"
     data-margin-left="{{ margin_left }}"
     data-first-column-width="{{ first_column_width }}"
     data-image-height="{{ image_height }}"
     style="max-width: {{ max_width }}px; margin-top: {{ margin_top }}px; {% if alignment == 'center' %}margin-left: auto; margin-right: auto;{% elsif alignment == 'right' %}margin-left: auto; margin-right: {{ margin_left }}px;{% else %}margin-left: {{ margin_left }}px;{% endif %}">
  <div class="spec-loading" style="text-align: center; padding: 20px;">
    Loading specifications...
  </div>
</div>

{% comment %} 
  Construiește obiectul JavaScript cu toate metafield-urile disponibile din Liquid
  Folosește informațiile din baza de date (toate metafield definitions) pentru a construi dinamic codul Liquid
  Template-ul ne spune ce metafield-uri să afișăm, iar valorile le obținem direct din Liquid
{% endcomment %}

{% if product %}
<script>
  // Inițializează obiectele pentru metafield-uri
  window.productMetafieldsData = {};
  window.variantMetafieldsData = {};
  
  // Funcție helper pentru a construi obiectul JavaScript cu metafield-urile din Liquid
  // Folosește informațiile din template pentru a accesa valorile direct din Liquid
  // NOTĂ: Valorile sunt deja construite în Liquid mai jos, această funcție doar le filtrează
  window.buildMetafieldsFromTemplate = function(template, allMetafieldDefinitions) {
    // Creează un map pentru a găsi rapid tipul unui metafield
    const metafieldTypeMap = {};
    if (allMetafieldDefinitions) {
      allMetafieldDefinitions.forEach(mf => {
        const key = `${mf.namespace}.${mf.key}.${mf.ownerType}`;
        metafieldTypeMap[key] = mf.type;
      });
    }
    
    // Filtrează doar metafield-urile care sunt în template din obiectul global construit în Liquid
    const filteredProductMetafields = {};
    const filteredVariantMetafields = {};
    
    // Folosește obiectul global construit în Liquid (mai jos)
    const allProductMetafields = window.allProductMetafieldsFromLiquid || {};
    const allVariantMetafields = window.allVariantMetafieldsFromLiquid || {};
    
    if (template && template.sections) {
      template.sections.forEach(section => {
        section.metafields.forEach(mf => {
          const metafieldKey = `${mf.namespace}.${mf.key}.${mf.ownerType}`;
          const metafieldType = mf.type || metafieldTypeMap[metafieldKey] || 'single_line_text_field';
          
          if (mf.ownerType === 'PRODUCT') {
            if (allProductMetafields[mf.namespace] && allProductMetafields[mf.namespace][mf.key] !== undefined) {
              if (!filteredProductMetafields[mf.namespace]) {
                filteredProductMetafields[mf.namespace] = {};
              }
              let value = allProductMetafields[mf.namespace][mf.key];
              
              // Procesează special file_reference, product_reference și collection_reference
              if (metafieldType === 'file_reference' && value) {
                // Pentru file_reference, valoarea este deja procesată în Liquid cu image_url
                // Trebuie să folosim valoarea directă din obiectul construit în Liquid
                filteredProductMetafields[mf.namespace][mf.key] = value;
              } else if (metafieldType === 'product_reference' && value && typeof value === 'object') {
                // Pentru product_reference, valoarea este deja un obiect Product
                filteredProductMetafields[mf.namespace][mf.key] = value;
              } else if (metafieldType === 'collection_reference' && value && typeof value === 'object') {
                // Pentru collection_reference, valoarea este deja un obiect Collection
                filteredProductMetafields[mf.namespace][mf.key] = value;
              } else {
                filteredProductMetafields[mf.namespace][mf.key] = value;
              }
            }
          } else if (mf.ownerType === 'VARIANT') {
            // Pentru variante, copiem toate variantele (vor fi filtrate la afișare)
            Object.keys(allVariantMetafields).forEach(variantId => {
              if (allVariantMetafields[variantId][mf.namespace] && allVariantMetafields[variantId][mf.namespace][mf.key] !== undefined) {
                if (!filteredVariantMetafields[variantId]) {
                  filteredVariantMetafields[variantId] = {};
                }
                if (!filteredVariantMetafields[variantId][mf.namespace]) {
                  filteredVariantMetafields[variantId][mf.namespace] = {};
                }
                let value = allVariantMetafields[variantId][mf.namespace][mf.key];
                
                // Procesează special file_reference, product_reference și collection_reference
                if (metafieldType === 'file_reference' && value) {
                  // Pentru file_reference, valoarea este deja procesată în Liquid cu image_url
                  filteredVariantMetafields[variantId][mf.namespace][mf.key] = value;
                } else if (metafieldType === 'product_reference' && value && typeof value === 'object') {
                  // Pentru product_reference, valoarea este deja un obiect Product
                  filteredVariantMetafields[variantId][mf.namespace][mf.key] = value;
                } else if (metafieldType === 'collection_reference' && value && typeof value === 'object') {
                  // Pentru collection_reference, valoarea este deja un obiect Collection
                  filteredVariantMetafields[variantId][mf.namespace][mf.key] = value;
                } else {
                  filteredVariantMetafields[variantId][mf.namespace][mf.key] = value;
                }
              }
            });
          }
        });
      });
    }
    
    window.productMetafieldsData = filteredProductMetafields;
    window.variantMetafieldsData = filteredVariantMetafields;
    
    console.log('Built metafields from template:', {
      filteredProductMetafields,
      filteredVariantMetafields,
      allProductMetafields,
      allVariantMetafields
    });
    
    return { productMetafields: filteredProductMetafields, variantMetafields: filteredVariantMetafields };
  };
  
  // Construiește obiectul JavaScript cu TOATE metafield-urile disponibile din Liquid
  // Acest obiect este construit direct în Liquid folosind toate metafield-urile disponibile
  // Pentru file_reference, folosim image_url filter pentru a obține URL-ul imaginii
  window.allProductMetafieldsFromLiquid = {
    {% comment %} Construiește pentru namespace-ul 'custom' {% endcomment %}
    {% if product.metafields.custom %}
    custom: {
      {% for metafield_pair in product.metafields.custom %}
        {% assign mf_key = metafield_pair[0] %}
        {% assign mf_value = metafield_pair[1] %}
        {% comment %} Pentru file_reference, folosim image_url filter {% endcomment %}
        {% if mf_value.type == 'file_reference' %}
          '{{ mf_key }}': {% if mf_value.value != blank %}'{{ mf_value.value | image_url }}'{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
        {% elsif mf_value.type == 'product_reference' %}
          '{{ mf_key }}': {% if mf_value.value %}{% assign ref_product = mf_value.value %}{"title": {{ ref_product.title | json }}, "featured_image": {% if ref_product.featured_image %}"{{ ref_product.featured_image | image_url: width: 300 }}"{% else %}null{% endif %}}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
        {% elsif mf_value.type == 'collection_reference' %}
          '{{ mf_key }}': {% if mf_value.value %}{% assign ref_collection = mf_value.value %}{"title": {{ ref_collection.title | json }}, "featured_image": {% if ref_collection.featured_image %}"{{ ref_collection.featured_image | image_url: width: 300 }}"{% else %}null{% endif %}}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
        {% elsif mf_value.type == 'dimension' %}
          '{{ mf_key }}': {% if mf_value.value != blank %}{% if mf_value.value.value != blank and mf_value.value.unit != blank %}'{{ mf_value.value.value }} {{ mf_value.value.unit }}'{% elsif mf_value.value.value != blank %}'{{ mf_value.value.value }}'{% else %}null{% endif %}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
        {% else %}
          '{{ mf_key }}': {{ mf_value.value | json }}{% unless forloop.last %},{% endunless %}
        {% endif %}
      {% endfor %}
    }{% if product.metafields.test_data %},{% endif %}
    {% endif %}
    {% comment %} Construiește pentru alte namespace-uri cunoscute {% endcomment %}
    {% if product.metafields.test_data %}
    test_data: {
      {% for metafield_pair in product.metafields.test_data %}
        {% assign mf_key = metafield_pair[0] %}
        {% assign mf_value = metafield_pair[1] %}
        {% comment %} Pentru file_reference, folosim image_url filter {% endcomment %}
        {% if mf_value.type == 'file_reference' %}
          '{{ mf_key }}': {% if mf_value.value != blank %}'{{ mf_value.value | image_url }}'{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
        {% elsif mf_value.type == 'product_reference' %}
          '{{ mf_key }}': {% if mf_value.value %}{% assign ref_product = mf_value.value %}{"title": {{ ref_product.title | json }}, "featured_image": {% if ref_product.featured_image %}"{{ ref_product.featured_image | image_url: width: 300 }}"{% else %}null{% endif %}}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
        {% elsif mf_value.type == 'collection_reference' %}
          '{{ mf_key }}': {% if mf_value.value %}{% assign ref_collection = mf_value.value %}{"title": {{ ref_collection.title | json }}, "featured_image": {% if ref_collection.featured_image %}"{{ ref_collection.featured_image | image_url: width: 300 }}"{% else %}null{% endif %}}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
        {% elsif mf_value.type == 'dimension' %}
          '{{ mf_key }}': {% if mf_value.value != blank %}{% if mf_value.value.value != blank and mf_value.value.unit != blank %}'{{ mf_value.value.value }} {{ mf_value.value.unit }}'{% elsif mf_value.value.value != blank %}'{{ mf_value.value.value }}'{% else %}null{% endif %}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
        {% else %}
          '{{ mf_key }}': {{ mf_value.value | json }}{% unless forloop.last %},{% endunless %}
        {% endif %}
      {% endfor %}
    }
    {% endif %}
  };
  
  // Construiește obiectul JavaScript cu TOATE metafield-urile VARIANT disponibile din Liquid
  // Folosim varianta curentă (selected_or_first_available_variant) pentru a obține metafield-urile
  // Pentru file_reference, folosim image_url filter pentru a obține URL-ul imaginii
  window.allVariantMetafieldsFromLiquid = {};
  {% assign current_variant = product.selected_or_first_available_variant %}
  {% if current_variant %}
    {% assign current_variant_id = current_variant.id | split: '/' | last %}
    window.allVariantMetafieldsFromLiquid['{{ current_variant_id }}'] = {
      {% if current_variant.metafields.custom %}
      custom: {
        {% for variant_mf_pair in current_variant.metafields.custom %}
          {% assign variant_mf_key = variant_mf_pair[0] %}
          {% assign variant_mf_value = variant_mf_pair[1] %}
          {% comment %} Pentru file_reference, folosim image_url filter {% endcomment %}
          {% if variant_mf_value.type.name == 'file_reference' %}
            '{{ variant_mf_key }}': {% if variant_mf_value.value != blank %}'{{ variant_mf_value.value | image_url }}'{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
          {% elsif variant_mf_value.type.name == 'product_reference' %}
            '{{ variant_mf_key }}': {% if variant_mf_value.value %}{% assign ref_product = variant_mf_value.value %}{"title": {{ ref_product.title | json }}, "featured_image": {% if ref_product.featured_image %}"{{ ref_product.featured_image | image_url: width: 300 }}"{% else %}null{% endif %}}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
          {% elsif variant_mf_value.type.name == 'collection_reference' %}
            '{{ variant_mf_key }}': {% if variant_mf_value.value %}{% assign ref_collection = variant_mf_value.value %}{"title": {{ ref_collection.title | json }}, "featured_image": {% if ref_collection.featured_image %}"{{ ref_collection.featured_image | image_url: width: 300 }}"{% else %}null{% endif %}}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
          {% elsif variant_mf_value.type.name == 'dimension' %}
            '{{ variant_mf_key }}': {% if variant_mf_value.value != blank %}{% if variant_mf_value.value.value != blank and variant_mf_value.value.unit != blank %}'{{ variant_mf_value.value.value }} {{ variant_mf_value.value.unit }}'{% elsif variant_mf_value.value.value != blank %}'{{ variant_mf_value.value.value }}'{% else %}null{% endif %}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
          {% else %}
            '{{ variant_mf_key }}': {{ variant_mf_value.value | json }}{% unless forloop.last %},{% endunless %}
          {% endif %}
        {% endfor %}
      }
      {% endif %}
    };
    
    // Construiește și pentru toate celelalte variante (pentru actualizare în timp real)
    {% for variant in product.variants %}
      {% assign variant_id = variant.id | split: '/' | last %}
      {% if variant_id != current_variant_id %}
        window.allVariantMetafieldsFromLiquid['{{ variant_id }}'] = {
          {% if variant.metafields.custom %}
          custom: {
            {% for variant_mf_pair in variant.metafields.custom %}
              {% assign variant_mf_key = variant_mf_pair[0] %}
              {% assign variant_mf_value = variant_mf_pair[1] %}
              {% comment %} Pentru file_reference, folosim image_url filter {% endcomment %}
              {% if variant_mf_value.type == 'file_reference' %}
                '{{ variant_mf_key }}': {% if variant_mf_value.value != blank %}'{{ variant_mf_value.value | image_url }}'{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
              {% elsif variant_mf_value.type == 'product_reference' %}
                '{{ variant_mf_key }}': {% if variant_mf_value.value %}{% assign ref_product = variant_mf_value.value %}{"title": {{ ref_product.title | json }}, "featured_image": {% if ref_product.featured_image %}"{{ ref_product.featured_image | image_url: width: 300 }}"{% else %}null{% endif %}}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
              {% elsif variant_mf_value.type == 'collection_reference' %}
                '{{ variant_mf_key }}': {% if variant_mf_value.value %}{% assign ref_collection = variant_mf_value.value %}{"title": {{ ref_collection.title | json }}, "featured_image": {% if ref_collection.featured_image %}"{{ ref_collection.featured_image | image_url: width: 300 }}"{% else %}null{% endif %}}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
              {% elsif variant_mf_value.type == 'dimension' %}
                '{{ variant_mf_key }}': {% if variant_mf_value.value != blank %}{% if variant_mf_value.value.value != blank and variant_mf_value.value.unit != blank %}'{{ variant_mf_value.value.value }} {{ variant_mf_value.value.unit }}'{% elsif variant_mf_value.value.value != blank %}'{{ variant_mf_value.value.value }}'{% else %}null{% endif %}{% else %}null{% endif %}{% unless forloop.last %},{% endunless %}
              {% else %}
                '{{ variant_mf_key }}': {{ variant_mf_value.value | json }}{% unless forloop.last %},{% endunless %}
              {% endif %}
            {% endfor %}
          }
          {% endif %}
        };
      {% endif %}
    {% endfor %}
  {% endif %}
</script>

<script>
(function() {
  const container = document.getElementById('specification-table-container-{{ block.id }}');
  if (!container) return;

  const productId = container.dataset.productId;
  // IMPORTANT: dataset.collectionId poate fi undefined (dacă atributul nu există), empty string, sau string cu valoare
  // Trebuie să normalizăm pentru a obține valoarea corectă
  let collectionId = container.dataset.collectionId;
  // Dacă atributul nu există sau este empty string sau "null", setăm la null
  if (!collectionId || collectionId === "" || collectionId === "null" || collectionId === null || collectionId === undefined) {
    collectionId = null;
  }
  const shopDomain = container.dataset.shop;
  
  // Debug logging
  console.log('[Liquid] Extracted values:', {
    productId: productId,
    collectionId: collectionId,
    collectionIdType: typeof collectionId,
    collectionIdRaw: container.dataset.collectionId,
    hasCollectionIdAttr: container.hasAttribute('data-collection-id'),
    shopDomain: shopDomain,
  });
  // Folosește app proxy pentru a accesa API-urile
  // App proxy URL: https://{shop-domain}/apps/{subpath}
  // Configurat în shopify.app.toml
  function getAppProxyUrl(subpath) {
    // Construiește URL-ul app proxy
    // Format: https://{shop-domain}/apps/{subpath}
    // Notă: shopDomain este deja în formatul corect (ex: description-container.myshopify.com)
    const proxyUrl = 'https://' + shopDomain + '/apps/' + subpath;
    console.log('Building app proxy URL:', { shopDomain, subpath, proxyUrl });
    return proxyUrl;
  }
  
  
  // Nu mai este nevoie de funcția buildLiquidMetafieldsFromTemplate
  // Valorile metafield-urilor sunt deja disponibile în Liquid prin product.metafields.namespace.key
  // Template-ul din API ne spune doar ce metafield-uri să afișăm și cum să le stilizăm

  // Stochează template-ul global
  let currentTemplate = null;
  
  // Funcție pentru a obține ID-ul variantei curente din URL
  function getCurrentVariantId() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('variant');
  }
  
  // Funcție pentru a actualiza valorile metafield-urilor în tabel
  // Folosește obiectul JavaScript construit în Liquid (window.productMetafieldsData și window.variantMetafieldsData)
  function updateMetafieldValuesFromLiquid(container) {
    const templateContainer = container.querySelector('[id^="specification-table-"]');
    if (!templateContainer) return;
    
    const metafieldCells = templateContainer.querySelectorAll('td[data-namespace][data-key]');
    const currentVariantId = getCurrentVariantId();
    
    // Obține setarea pentru înălțimea imaginilor
    const imageHeight = container.dataset.imageHeight || '100';
    
    // Obține obiectele cu metafield-uri din Liquid
    const productMetafields = window.productMetafieldsData || {};
    const variantMetafields = window.variantMetafieldsData || {};
    
    metafieldCells.forEach(cell => {
      const namespace = cell.dataset.namespace;
      const key = cell.dataset.key;
      const ownerType = cell.dataset.ownerType || 'PRODUCT';
      const metafieldType = cell.dataset.type || 'single_line_text_field';
      const valueElement = cell.querySelector('[data-metafield-value]');
      if (!valueElement) return;
      
      // Extrage prefix și suffix din data-attributes
      // Folosim getAttribute pentru a obține valoarea exactă (dataset poate transforma caracterele)
      const prefix = valueElement.getAttribute('data-prefix') || '';
      const suffix = valueElement.getAttribute('data-suffix') || '';
      
      let value = null;
      
      // Prioritizează metafield-urile VARIANT dacă există pentru varianta curentă
      // Folosim varianta din URL sau varianta implicită (selected_or_first_available_variant)
      if (ownerType === 'VARIANT') {
        // Încearcă să găsească metafield-ul pentru varianta curentă
        if (currentVariantId && variantMetafields[currentVariantId] && 
            variantMetafields[currentVariantId][namespace] && 
            variantMetafields[currentVariantId][namespace][key] !== undefined) {
          value = variantMetafields[currentVariantId][namespace][key];
        } else {
          // Dacă nu găsește pentru varianta din URL, folosește prima variantă disponibilă
          const firstVariantId = Object.keys(variantMetafields)[0];
          if (firstVariantId && variantMetafields[firstVariantId] && 
              variantMetafields[firstVariantId][namespace] && 
              variantMetafields[firstVariantId][namespace][key] !== undefined) {
            value = variantMetafields[firstVariantId][namespace][key];
          }
        }
      }
      
      // Dacă nu am găsit valoarea pentru VARIANT, folosește PRODUCT metafield
      if (value === null && ownerType === 'PRODUCT' && productMetafields[namespace] && productMetafields[namespace][key] !== undefined) {
        value = productMetafields[namespace][key];
      } else if (value === null && productMetafields[namespace] && productMetafields[namespace][key] !== undefined) {
        // Fallback la PRODUCT metafield dacă nu există variant
        value = productMetafields[namespace][key];
      }
      
      // Randare diferită în funcție de tipul metafield-ului
      renderMetafieldValue(valueElement, value, metafieldType, ownerType, namespace, key, imageHeight, prefix, suffix);
    });
  }
  
  // Funcție pentru a randa valoarea metafield-ului în funcție de tip
  function renderMetafieldValue(element, value, metafieldType, ownerType, namespace, key, imageHeight, prefix, suffix) {
    if (value === null || value === undefined || value === '') {
      element.innerHTML = 'N/A';
      return;
    }
    
    // Folosește înălțimea setată sau default 100px
    const height = imageHeight || '100';
    
    // Funcție helper pentru a aplica prefix și suffix doar la text (nu la imagini sau obiecte)
    function applyPrefixSuffix(textValue, prefixValue, suffixValue) {
      if (!textValue) return textValue;
      let result = String(textValue);
      if (prefixValue && prefixValue.trim() !== '') {
        result = prefixValue.trim() + ' ' + result;
      }
      if (suffixValue && suffixValue.trim() !== '') {
        result = result + ' ' + suffixValue.trim();
      }
      return result;
    }
  
    // Pentru multi_line_text_field și single_line_text_field - randare text simplă
    if (metafieldType === 'multi_line_text_field' || metafieldType === 'single_line_text_field') {
      if (typeof value === 'object') {
        element.textContent = JSON.stringify(value);
      } else {
        // Aplică prefix și suffix pentru text
        const formattedValue = applyPrefixSuffix(value, prefix, suffix);
        element.textContent = formattedValue;
      }
    }
    // Pentru file_reference - randare imagine
    // Valoarea este deja procesată în Liquid cu image_url, deci este un string cu URL-ul
    else if (metafieldType === 'file_reference') {
      if (value && value !== '' && value !== 'null') {
        element.innerHTML = '<img src="' + escapeHtml(String(value)) + '" style="max-width: 100%; height: ' + height + 'px; object-fit: contain;" />';
      } else {
        element.innerHTML = 'N/A';
      }
    }
    // Pentru product_reference - randare produs cu imagine și titlu
    // Valoarea este deja procesată în Liquid și este un obiect cu title și featured_image
    else if (metafieldType === 'product_reference') {
      if (value && typeof value === 'object') {
        const productImage = value.featured_image || value.image || '';
        const productTitle = value.title || '';
        let html = '';
        if (productImage && productImage !== 'null') {
          html += '<div style="display:flex;align-items:center;"><img src="' + escapeHtml(String(productImage)) + '" alt="' + escapeHtml(productTitle) + '" style="max-width: 100%; height: ' + height + 'px; object-fit: contain;" />';
        }
        if (productTitle) {
          html +=  '<span style="font-weight:bold;margin-left:30px">' + escapeHtml(productTitle) + '</span></div>';
        }
        element.innerHTML = html || 'N/A';
      } else {
        element.innerHTML = 'N/A';
      }
    }
    // Pentru collection_reference - randare colecție cu imagine și titlu
    // Valoarea este deja procesată în Liquid și este un obiect cu title și featured_image
    else if (metafieldType === 'collection_reference') {
      if (value && typeof value === 'object') {
        const collectionImage = value.featured_image || value.image || '';
        const collectionTitle = value.title || '';
        let html = '';
        if (collectionImage && collectionImage !== 'null') {
          html += '<div><img src="' + escapeHtml(String(collectionImage)) + '" alt="' + escapeHtml(collectionTitle) + '" style="max-width: 100%; height: ' + height + 'px; object-fit: contain;" /></div>';
        }
        if (collectionTitle) {
          html += '<div style="font-weight:bold;text-align:center;">' + escapeHtml(collectionTitle) + '</div>';
        }
        element.innerHTML = html || 'N/A';
      } else {
        element.innerHTML = 'N/A';
      }
    }
    // Pentru dimension - randare valoare dinamică bazată pe namespace și key
    else if (metafieldType === 'dimension') {
      // Valoarea este deja procesată în Liquid și este valoarea metafield-ului curent
      if (typeof value === 'object') {
        element.textContent = JSON.stringify(value);
      } else {
        // Aplică prefix și suffix pentru dimension
        const formattedValue = applyPrefixSuffix(value, prefix, suffix);
        element.textContent = formattedValue;
      }
    }
    // Pentru alte tipuri - randare text simplă
    else {
      if (typeof value === 'object') {
        element.textContent = JSON.stringify(value);
      } else {
        // Aplică prefix și suffix pentru alte tipuri text
        const formattedValue = applyPrefixSuffix(value, prefix, suffix);
        element.textContent = formattedValue;
      }
    }
  }
  
  // Folosește app proxy pentru a accesa API-ul template
  // App proxy URL: https://{shop-domain}/apps/description-container-v1
  // IMPORTANT: Trimitem AMBELE productId și collectionId dacă există
  // pentru ca lookup-ul să poată verifica priority 1 (PRODUCT) și priority 2 (COLLECTION)
  const templateProxyUrl = getAppProxyUrl('description-container-v1');
  let templateApiUrl = templateProxyUrl + '?shop=' + encodeURIComponent(shopDomain);
  if (productId) {
    templateApiUrl += '&productId=' + encodeURIComponent(productId);
  }
  if (collectionId) {
    templateApiUrl += '&collectionId=' + encodeURIComponent(collectionId);
  }
  
  console.log('Template API URL (app proxy):', templateApiUrl);
  console.log('Shop domain:', shopDomain);
  console.log('Product ID:', productId);
  console.log('Collection ID:', collectionId);
  
  // Face request către API prin app proxy
  fetch(templateApiUrl, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
  })
    .then(response => {
      console.log('[Fetch] Response status:', response.status);
      console.log('[Fetch] Response ok?', response.ok);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log('[Fetch] Parsing JSON response...');
      return response.json();
    })
    .then(async data => {
      console.log('[Fetch] Template data received:', data);
      console.log('[Fetch] Has template?', !!data.template);
      
      if (data.template) {
        currentTemplate = data.template;
        
        // Debug logging pentru split view
        console.log('[Fetch] Template split view settings:', {
          splitViewPerSection: data.template.splitViewPerSection,
          splitViewPerMetafield: data.template.splitViewPerMetafield,
          sectionsCount: data.template.sections?.length || 0
        });
        
        // Construiește obiectul cu metafield-urile din Liquid folosind template-ul și toate metafield definitions
        console.log('[Fetch] Building metafields from template...');
        if (window.buildMetafieldsFromTemplate) {
          window.buildMetafieldsFromTemplate(data.template, data.allMetafieldDefinitions);
          console.log('[Fetch] Metafields built successfully');
        } else {
          console.warn('[Fetch] buildMetafieldsFromTemplate function not found!');
        }
        
        // Renderizează template-ul - valorile metafield-urilor vor fi populate direct din Liquid
        console.log('[Fetch] About to call renderTemplate...');
        try {
          renderTemplate(container, data.template);
          console.log('[Fetch] renderTemplate completed successfully');
        } catch (error) {
          console.error('[Fetch] Error in renderTemplate:', error);
          console.error('[Fetch] Error name:', error.name);
          console.error('[Fetch] Error message:', error.message);
          console.error('[Fetch] Error stack:', error.stack);
          container.innerHTML = '<div style="text-align: center; padding: 20px; color: #ff0000;">Error rendering template. Check console for details.</div>';
          return;
        }
        
        // Populează valorile metafield-urilor din obiectul JavaScript construit în Liquid
        updateMetafieldValuesFromLiquid(container);
        
        // Adaugă listener pentru schimbarea variantei (pentru actualizare în timp real)
        setupVariantChangeListener(container, data.template);
      } else {
        console.warn('No template found in response');
        container.innerHTML = '';
      }
    })
    .catch(error => {
      console.error('Error loading template:', error);
        console.error('Error details:', {
        message: error.message,
        stack: error.stack,
        shopDomain: shopDomain,
        productId: productId,
        collectionId: collectionId
      });
      container.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">Unable to load specifications. Check console for details.</div>';
    });
  
  // Funcție pentru a asculta schimbările de variantă
  function setupVariantChangeListener(container, template) {
    let currentVariantId = null;
    
    // Funcție pentru a obține ID-ul variantei din URL
    function getVariantIdFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      const variantParam = urlParams.get('variant');
      return variantParam;
    }
    
    // Funcție pentru a actualiza metafield-urile variant
    // Actualizează valorile din obiectul JavaScript construit în Liquid
    function updateVariantMetafields(variantId) {
      // Reconstruiește obiectul cu metafield-urile pentru varianta curentă
      // Folosim varianta din URL pentru a obține metafield-urile corecte
      if (variantId && window.allVariantMetafieldsFromLiquid && window.allVariantMetafieldsFromLiquid[variantId]) {
        // Actualizează valorile metafield-urilor din obiectul JavaScript
        updateMetafieldValuesFromLiquid(container);
      } else {
        // Dacă nu găsim varianta, folosim varianta implicită
        updateMetafieldValuesFromLiquid(container);
      }
    }
    
    // Verifică inițial varianta din URL
    currentVariantId = getVariantIdFromUrl();
    if (currentVariantId) {
      updateVariantMetafields(currentVariantId);
    }
    
    // Ascultă schimbările în URL (când se schimbă varianta)
    let lastVariantId = currentVariantId;
    setInterval(() => {
      const newVariantId = getVariantIdFromUrl();
      if (newVariantId !== lastVariantId) {
        lastVariantId = newVariantId;
        currentVariantId = newVariantId;
        updateVariantMetafields(newVariantId);
      }
    }, 100); // Verifică la fiecare 100ms
    
    // Ascultă evenimentele de schimbare a variantei (dacă există)
    document.addEventListener('variant:change', (event) => {
      if (event.detail && event.detail.variantId) {
        currentVariantId = event.detail.variantId;
        updateVariantMetafields(currentVariantId);
      }
    });
    
    // Ascultă schimbările în DOM (când Shopify actualizează varianta)
    const observer = new MutationObserver(() => {
      const newVariantId = getVariantIdFromUrl();
      if (newVariantId !== currentVariantId) {
        currentVariantId = newVariantId;
        updateVariantMetafields(newVariantId);
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['data-variant-id', 'data-selected-variant']
    });
  }
  
  // Funcție helper pentru a escapa HTML (mutată aici pentru a fi disponibilă în renderTemplate)
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  function renderTemplate(container, template) {
    console.log('[renderTemplate] START - Function called');
    console.log('[renderTemplate] Template:', template);
    console.log('[renderTemplate] Container:', container);
    
    const styling = template.styling;
    // Citește setările din container
    const firstColumnWidth = container.dataset.firstColumnWidth || '40';
    
    // Escape template.id o singură dată pentru a-l folosi în string-uri HTML
    const escapedTemplateId = escapeHtml(template.id);
    
    console.log('[renderTemplate] Styling:', styling);
    console.log('[renderTemplate] First column width:', firstColumnWidth);
    
    // Debug: verifică dacă template-ul conține flag-urile hideFromPC/hideFromMobile
    console.log('renderTemplate - Template sections:', template.sections?.map(s => ({
      heading: s.heading,
      metafields: s.metafields?.map(mf => ({
        namespace: mf.namespace,
        key: mf.key,
        hideFromPC: mf.hideFromPC,
        hideFromMobile: mf.hideFromMobile,
        hideFromPCType: typeof mf.hideFromPC,
        hideFromMobileType: typeof mf.hideFromMobile
      }))
    })));
    
    // Construiește CSS variables pentru stilurile dinamice
    // NOUA LOGICĂ: Specification Text Color și Value Text Color separate
    let cssVars = '--dc-bg-color: ' + (styling.backgroundColor || '#ffffff') + '; ';
    // Backward compatibility: dacă există textColor vechi, îl folosim pentru ambele
    const specTextColor = styling.specificationTextColor || styling.textColor || '#000000';
    const valueTextColor = styling.valueTextColor || styling.textColor || '#000000';
    cssVars += '--dc-specification-text-color: ' + specTextColor + '; ';
    cssVars += '--dc-value-text-color: ' + valueTextColor + '; ';
    cssVars += '--dc-heading-color: ' + (styling.headingColor || '#000000') + '; ';
    cssVars += '--dc-heading-font-size: ' + (styling.headingFontSize || '18px') + '; ';
    cssVars += '--dc-heading-font-weight: ' + (styling.headingFontWeight || 'bold') + '; ';
    cssVars += '--dc-heading-font-family: ' + (styling.headingFontFamily || 'inherit') + '; ';
    cssVars += '--dc-text-font-size: ' + (styling.textFontSize || '14px') + '; ';
    cssVars += '--dc-text-font-family: ' + (styling.textFontFamily || 'inherit') + '; ';
    cssVars += '--dc-text-transform: ' + (styling.textTransform || 'none') + '; ';
    cssVars += '--dc-border-radius: ' + (styling.borderRadius || '0px') + '; ';
    cssVars += '--dc-padding: ' + (styling.padding || '20px') + '; ';
    cssVars += '--dc-first-column-width: ' + firstColumnWidth + '%; ';
    if (styling.sectionBorderEnabled) {
      cssVars += '--dc-border: ' + (styling.sectionBorderWidth || '1px') + ' ' + (styling.sectionBorderStyle || 'solid') + ' ' + (styling.sectionBorderColor || '#000000') + '; ';
    } else {
      cssVars += '--dc-border: none; ';
    }
    cssVars += '--dc-row-border: ' + (styling.rowBorderEnabled ? (styling.rowBorderWidth || '1px') + ' ' + (styling.rowBorderStyle || 'solid') + ' ' + (styling.rowBorderColor || '#000000') : 'none') + '; ';
    cssVars += '--dc-odd-row-bg: ' + (styling.oddRowBackgroundColor || '#f0f0f0') + '; ';
    cssVars += '--dc-even-row-bg: ' + (styling.evenRowBackgroundColor || '#ffffff') + '; ';
    cssVars += '--dc-odd-column-bg: ' + (styling.oddColumnBackgroundColor || '#ff0000') + '; ';
    cssVars += '--dc-even-column-bg: ' + (styling.evenColumnBackgroundColor || '#00ff00') + '; ';
    cssVars += '--dc-td-bg: ' + (styling.tdBackgroundColor || 'transparent') + '; ';
    cssVars += '--dc-row-bg-enabled: ' + (styling.rowBackgroundEnabled ? '1' : '0') + '; ';
    cssVars += '--dc-column-bg-enabled: ' + (styling.columnBackgroundEnabled ? '1' : '0') + '; ';
    // See More Button Styling
    cssVars += '--dc-see-more-button-color: ' + (styling.seeMoreButtonColor || '#000000') + '; ';
    cssVars += '--dc-see-more-button-background: ' + (styling.seeMoreButtonBackground || 'transparent') + '; ';
    cssVars += '--dc-see-more-button-font-size: ' + (styling.seeMoreButtonFontSize || '14px') + '; ';
    cssVars += '--dc-see-more-button-font-family: ' + (styling.seeMoreButtonFontFamily || 'Arial') + '; ';
    cssVars += '--dc-see-more-button-padding: ' + (styling.seeMoreButtonPadding || '8px') + '; ';
    cssVars += '--dc-see-more-button-border-radius: ' + (styling.seeMoreButtonBorderRadius || '0px') + '; ';
    if (styling.seeMoreButtonBorderEnabled) {
      cssVars += '--dc-see-more-button-border: ' + (styling.seeMoreButtonBorderWidth || '1px') + ' ' + (styling.seeMoreButtonBorderStyle || 'solid') + ' ' + (styling.seeMoreButtonBorderColor || '#000000') + '; ';
    } else {
      cssVars += '--dc-see-more-button-border: none; ';
    }
    
    let html = '<div id="specification-table-' + escapedTemplateId + '" class="dc_container" style="' + cssVars + '">';
    
    // Colectează toate metafields-urile din toate secțiunile cu informații despre secțiune
    const allMetafieldsWithSection = [];
    // Construiește un obiect care mapează indexul secțiunii la valoarea hideSectionWhenEmpty
    const sectionHideWhenEmpty = {};
    template.sections.forEach((section, sectionIndex) => {
      // Setează valoarea hideSectionWhenEmpty pentru această secțiune (default: true)
      sectionHideWhenEmpty[sectionIndex] = section.hideSectionWhenEmpty !== undefined && section.hideSectionWhenEmpty !== null ? section.hideSectionWhenEmpty : true;
      
      if (section.metafields && section.metafields.length > 0) {
        section.metafields.forEach((metafield, mfIndex) => {
          // Asigură-te că toate proprietățile sunt copiate, inclusiv hideFromPC și hideFromMobile
          allMetafieldsWithSection.push({
            namespace: metafield.namespace,
            key: metafield.key,
            ownerType: metafield.ownerType,
            name: metafield.name,
            type: metafield.type,
            customName: metafield.customName,
            tooltipEnabled: metafield.tooltipEnabled,
            tooltipText: metafield.tooltipText,
            hideFromPC: metafield.hideFromPC !== undefined ? metafield.hideFromPC : false,
            hideFromMobile: metafield.hideFromMobile !== undefined ? metafield.hideFromMobile : false,
            prefix: metafield.prefix || null,
            suffix: metafield.suffix || null,
            sectionIndex: sectionIndex,
            sectionHeading: section.heading,
            mfIndex: mfIndex
          });
        });
      }
    });
    
    const seeMoreEnabled = template.seeMoreEnabled || false;
    const seeMoreHideFromPC = template.seeMoreHideFromPC === true || template.seeMoreHideFromPC === 'true';
    const seeMoreHideFromMobile = template.seeMoreHideFromMobile === true || template.seeMoreHideFromMobile === 'true';
    
    // Obține metafield-urile cu valori din obiectele construite în Liquid (pentru verificarea valorilor)
    const productMetafields = window.productMetafieldsData || {};
    const variantMetafields = window.variantMetafieldsData || {};
    
    // Funcție pentru a verifica dacă un metafield are valoare
    function metafieldHasValue(metafield) {
      let hasValue = false;
      let value = null;
      
      if (metafield.ownerType === 'PRODUCT') {
        if (productMetafields[metafield.namespace] && 
            productMetafields[metafield.namespace][metafield.key] !== undefined) {
          value = productMetafields[metafield.namespace][metafield.key];
          // Verifică dacă valoarea nu este goală, null, undefined sau "N/A"
          hasValue = value !== null && 
                    value !== undefined && 
                    value !== '' && 
                    (typeof value !== 'string' || value.trim() !== '') &&
                    value !== 'null' && 
                    value !== 'undefined' &&
                    (typeof value !== 'string' || value.trim().toUpperCase() !== 'N/A');
          
          // Pentru obiecte (product_reference, collection_reference), verifică dacă au cel puțin title sau image
          if (hasValue && typeof value === 'object') {
            hasValue = value.title || value.featured_image || value.image;
          }
        }
      } else if (metafield.ownerType === 'VARIANT') {
        // Pentru variante, verifică dacă există cel puțin o variantă cu valoare
        Object.keys(variantMetafields).forEach(variantId => {
          if (!hasValue && variantMetafields[variantId] && 
              variantMetafields[variantId][metafield.namespace] && 
              variantMetafields[variantId][metafield.namespace][metafield.key] !== undefined) {
            value = variantMetafields[variantId][metafield.namespace][metafield.key];
            hasValue = value !== null && 
                      value !== undefined && 
                      value !== '' && 
                      (typeof value !== 'string' || value.trim() !== '') &&
                      value !== 'null' && 
                      value !== 'undefined' &&
                      (typeof value !== 'string' || value.trim().toUpperCase() !== 'N/A');
            
            // Pentru obiecte, verifică dacă au cel puțin title sau image
            if (hasValue && typeof value === 'object') {
              hasValue = value.title || value.featured_image || value.image;
            }
          }
        });
      }
      
      return hasValue;
    }
    
    // Filtrează metafields-urile care au valori (vizibile)
    const visibleMetafields = allMetafieldsWithSection.filter(metafield => metafieldHasValue(metafield));
    const totalVisibleRows = visibleMetafields.length;
    
    // Determină ce rânduri să afișeze pe baza flag-urilor
    // IMPORTANT: Folosim visibleMetafields pentru a afișa doar metafields-urile cu valori
    // Dacă seeMoreHideFromPC este true: pe PC afișează toate, pe mobile primele 10 + buton
    // Dacă seeMoreHideFromMobile este true: pe mobile afișează toate, pe PC primele 10 + buton
    // Dacă ambele sunt false: funcționează normal (primele 10 + buton peste tot)
    let displayRowsPC = allMetafieldsWithSection;
    let displayRowsMobile = allMetafieldsWithSection;
    let hasMorePC = false;
    let hasMoreMobile = false;
    
    if (seeMoreEnabled) {
      if (seeMoreHideFromPC) {
        // Pe PC: toate metafields-urile VIZIBILE (cu valori)
        displayRowsPC = visibleMetafields;
        // Pe mobile: primele 10 metafields-uri VIZIBILE (cu valori)
        displayRowsMobile = visibleMetafields.slice(0, 10);
        hasMorePC = false;
        hasMoreMobile = totalVisibleRows > 10;
      } else if (seeMoreHideFromMobile) {
        // Pe PC: primele 10 metafields-uri VIZIBILE (cu valori)
        displayRowsPC = visibleMetafields.slice(0, 10);
        // Pe mobile: toate metafields-urile VIZIBILE (cu valori)
        displayRowsMobile = visibleMetafields;
        hasMorePC = totalVisibleRows > 10;
        hasMoreMobile = false;
      } else {
        // Normal: primele 10 metafields-uri VIZIBILE (cu valori) + buton peste tot
        displayRowsPC = visibleMetafields.slice(0, 10);
        displayRowsMobile = visibleMetafields.slice(0, 10);
        hasMorePC = totalVisibleRows > 10;
        hasMoreMobile = totalVisibleRows > 10;
      }
    } else {
      // Dacă seeMoreEnabled este false, afișăm toate metafields-urile VIZIBILE
      displayRowsPC = visibleMetafields;
      displayRowsMobile = visibleMetafields;
    }
    
    // Grupează toate rândurile pe secțiuni (pentru a ști ce secțiuni există)
    const allGroupedBySection = {};
    allMetafieldsWithSection.forEach(item => {
      if (!allGroupedBySection[item.sectionIndex]) {
        allGroupedBySection[item.sectionIndex] = {
          heading: item.sectionHeading,
          allMetafields: [],
          displayMetafieldsPC: [],
          displayMetafieldsMobile: [],
          hiddenMetafieldsPC: [],
          hiddenMetafieldsMobile: []
        };
      }
      allGroupedBySection[item.sectionIndex].allMetafields.push(item);
    });
    
    // Separe rândurile pentru PC și mobile
    displayRowsPC.forEach(item => {
      allGroupedBySection[item.sectionIndex].displayMetafieldsPC.push(item);
    });
    displayRowsMobile.forEach(item => {
      allGroupedBySection[item.sectionIndex].displayMetafieldsMobile.push(item);
    });
    
    // Separe rândurile ascunse pentru PC și mobile (doar metafields-urile cu valori)
    if (hasMorePC) {
      const hiddenRowsPC = visibleMetafields.slice(10);
      hiddenRowsPC.forEach(item => {
        allGroupedBySection[item.sectionIndex].hiddenMetafieldsPC.push(item);
      });
    }
    if (hasMoreMobile) {
      const hiddenRowsMobile = visibleMetafields.slice(10);
      hiddenRowsMobile.forEach(item => {
        allGroupedBySection[item.sectionIndex].hiddenMetafieldsMobile.push(item);
      });
    }
    
    // SVG pentru săgeată modernă
    const arrowDownSvg = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: inline-block; transition: transform 0.3s ease;"><path d="M5 7.5L10 12.5L15 7.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
    
    // Verifică dacă split view este activat
    const splitViewPerSection = template.splitViewPerSection === true || template.splitViewPerSection === 'true';
    const splitViewPerMetafield = template.splitViewPerMetafield === true || template.splitViewPerMetafield === 'true';
    
    // Dacă splitViewPerSection este activat, grupează secțiunile pentru distribuție în 2 coloane
    let sectionsToRender = [];
    let leftColumnSections = [];
    let rightColumnSections = [];
    
    if (splitViewPerSection) {
      // Colectează toate secțiunile care trebuie afișate
      Object.keys(allGroupedBySection).forEach(sectionIndex => {
        const sectionIdx = parseInt(sectionIndex);
        const sectionData = allGroupedBySection[sectionIndex];
        
        // Verifică dacă secțiunea trebuie ascunsă (toate metafield-urile sunt goale)
        const sectionVisibleMetafields = visibleMetafields.filter(mf => mf.sectionIndex === sectionIdx);
        const shouldHideSection = sectionHideWhenEmpty[sectionIdx] && sectionVisibleMetafields.length === 0;
        
        // Skip secțiunile care trebuie ascunse sau care nu au rânduri de afișat și nu au rânduri ascunse
        if (!shouldHideSection && 
            (sectionData.displayMetafieldsPC.length > 0 || sectionData.displayMetafieldsMobile.length > 0 || 
             sectionData.hiddenMetafieldsPC.length > 0 || sectionData.hiddenMetafieldsMobile.length > 0)) {
          sectionsToRender.push({ sectionIndex: sectionIdx, sectionData });
        }
      });
      
      // Distribuie secțiunile în 2 coloane
      leftColumnSections = [];
      rightColumnSections = [];
      sectionsToRender.forEach((section, index) => {
        if (index % 2 === 0) {
          leftColumnSections.push(section);
        } else {
          rightColumnSections.push(section);
        }
      });
    
      // Renderizează coloanele doar dacă există secțiuni de renderizat
      if (sectionsToRender.length > 0) {
        html += '<div class="dc_split_view_sections" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">';
        html += '<div class="dc_split_view_column dc_split_view_left">';
        leftColumnSections.forEach(({ sectionIndex, sectionData }) => {
          const sectionIdx = sectionIndex;
          // Verifică flag-urile pentru accordion
          const isAccordionHideFromPC = template.isAccordionHideFromPC === true || template.isAccordionHideFromPC === 'true';
          const isAccordionHideFromMobile = template.isAccordionHideFromMobile === true || template.isAccordionHideFromMobile === 'true';
          const showAccordionPC = template.isAccordion && !isAccordionHideFromPC;
          const showAccordionMobile = template.isAccordion && !isAccordionHideFromMobile;
          
          html += '<div class="dc_section">';
          html += '<div class="dc_accordion_pc_version">';
          if (showAccordionPC) {
            html += '<div class="dc_section_header" onclick="toggleSpecSection(' + sectionIdx + ', \'' + escapedTemplateId + '\', \'pc\')">';
            html += '<span>' + escapeHtml(sectionData.heading) + '</span>';
            html += '<span class="dc_accordion_arrow" id="spec-arrow-pc-' + escapedTemplateId + '-' + sectionIdx + '">' + arrowDownSvg + '</span>';
            html += '</div>';
            html += '<div id="spec-section-pc-' + escapedTemplateId + '-' + sectionIdx + '" class="dc_section_content" style="display: none;">';
            html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsPC, 'pc', splitViewPerMetafield);
            html += '</div>';
          } else {
            html += '<h3 class="dc_heading">';
            html += escapeHtml(sectionData.heading);
            html += '</h3>';
            html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsPC, 'pc', splitViewPerMetafield);
          }
          html += '</div>';
          html += '<div class="dc_accordion_mobile_version">';
          if (showAccordionMobile) {
            html += '<div class="dc_section_header" onclick="toggleSpecSection(' + sectionIdx + ', \'' + escapedTemplateId + '\', \'mobile\')">';
            html += '<span>' + escapeHtml(sectionData.heading) + '</span>';
            html += '<span class="dc_accordion_arrow" id="spec-arrow-mobile-' + escapedTemplateId + '-' + sectionIdx + '">' + arrowDownSvg + '</span>';
            html += '</div>';
            html += '<div id="spec-section-mobile-' + escapedTemplateId + '-' + sectionIdx + '" class="dc_section_content" style="display: none;">';
            html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsMobile, 'mobile', splitViewPerMetafield);
            html += '</div>';
          } else {
            html += '<h3 class="dc_heading">';
            html += escapeHtml(sectionData.heading);
            html += '</h3>';
            html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsMobile, 'mobile', splitViewPerMetafield);
          }
          html += '</div>';
          html += '</div>';
        });
        html += '</div>';
        html += '<div class="dc_split_view_column dc_split_view_right">';
        rightColumnSections.forEach(({ sectionIndex, sectionData }) => {
          const sectionIdx = sectionIndex;
          // Verifică flag-urile pentru accordion
          const isAccordionHideFromPC = template.isAccordionHideFromPC === true || template.isAccordionHideFromPC === 'true';
          const isAccordionHideFromMobile = template.isAccordionHideFromMobile === true || template.isAccordionHideFromMobile === 'true';
          const showAccordionPC = template.isAccordion && !isAccordionHideFromPC;
          const showAccordionMobile = template.isAccordion && !isAccordionHideFromMobile;
          
          html += '<div class="dc_section">';
          html += '<div class="dc_accordion_pc_version">';
          if (showAccordionPC) {
            html += '<div class="dc_section_header" onclick="toggleSpecSection(' + sectionIdx + ', \'' + escapedTemplateId + '\', \'pc\')">';
            html += '<span>' + escapeHtml(sectionData.heading) + '</span>';
            html += '<span class="dc_accordion_arrow" id="spec-arrow-pc-' + escapedTemplateId + '-' + sectionIdx + '">' + arrowDownSvg + '</span>';
            html += '</div>';
            html += '<div id="spec-section-pc-' + escapedTemplateId + '-' + sectionIdx + '" class="dc_section_content" style="display: none;">';
            html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsPC, 'pc', splitViewPerMetafield);
            html += '</div>';
          } else {
            html += '<h3 class="dc_heading">';
            html += escapeHtml(sectionData.heading);
            html += '</h3>';
            html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsPC, 'pc', splitViewPerMetafield);
          }
          html += '</div>';
          html += '<div class="dc_accordion_mobile_version">';
          if (showAccordionMobile) {
            html += '<div class="dc_section_header" onclick="toggleSpecSection(' + sectionIdx + ', \'' + escapedTemplateId + '\', \'mobile\')">';
            html += '<span>' + escapeHtml(sectionData.heading) + '</span>';
            html += '<span class="dc_accordion_arrow" id="spec-arrow-mobile-' + escapedTemplateId + '-' + sectionIdx + '">' + arrowDownSvg + '</span>';
            html += '</div>';
            html += '<div id="spec-section-mobile-' + escapedTemplateId + '-' + sectionIdx + '" class="dc_section_content" style="display: none;">';
            html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsMobile, 'mobile', splitViewPerMetafield);
            html += '</div>';
          } else {
            html += '<h3 class="dc_heading">';
            html += escapeHtml(sectionData.heading);
            html += '</h3>';
            html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsMobile, 'mobile', splitViewPerMetafield);
          }
          html += '</div>';
          html += '</div>';
        });
        html += '</div>';
        html += '</div>'; // Închide dc_split_view_sections
      }
    } else {
      // Renderizează secțiunile normal (fără split view per section)
      Object.keys(allGroupedBySection).forEach(sectionIndex => {
      const sectionIdx = parseInt(sectionIndex);
      const sectionData = allGroupedBySection[sectionIndex];
      
      // Skip secțiunile care nu au rânduri de afișat și nu au rânduri ascunse
      if (sectionData.displayMetafieldsPC.length === 0 && sectionData.displayMetafieldsMobile.length === 0 && 
          sectionData.hiddenMetafieldsPC.length === 0 && sectionData.hiddenMetafieldsMobile.length === 0) {
        return;
      }
      
      // Verifică flag-urile pentru accordion
      const isAccordionHideFromPC = template.isAccordionHideFromPC === true || template.isAccordionHideFromPC === 'true';
      const isAccordionHideFromMobile = template.isAccordionHideFromMobile === true || template.isAccordionHideFromMobile === 'true';
      
      // Determină ce versiune să afișeze pe PC și mobile
      const showAccordionPC = template.isAccordion && !isAccordionHideFromPC;
      const showAccordionMobile = template.isAccordion && !isAccordionHideFromMobile;
      
      // Dacă secțiunea nu are rânduri de afișat dar are rânduri ascunse, afișează doar heading-ul
      // (rândurile vor fi adăugate când se face click pe "See more")
      if (sectionData.displayMetafieldsPC.length === 0 && sectionData.displayMetafieldsMobile.length === 0 && 
          (sectionData.hiddenMetafieldsPC.length > 0 || sectionData.hiddenMetafieldsMobile.length > 0)) {
        html += '<div class="dc_section">';
        
        // Versiunea pentru PC
        html += '<div class="dc_accordion_pc_version">';
        if (showAccordionPC) {
          html += '<div class="dc_section_header" onclick="toggleSpecSection(' + sectionIdx + ', \'' + escapedTemplateId + '\', \'pc\')">';
          html += '<span>' + escapeHtml(sectionData.heading) + '</span>';
          html += '<span class="dc_accordion_arrow" id="spec-arrow-pc-' + escapedTemplateId + '-' + sectionIdx + '">' + arrowDownSvg + '</span>';
          html += '</div>';
          html += '<div id="spec-section-pc-' + escapedTemplateId + '-' + sectionIdx + '" class="dc_section_content" style="display: none;">';
          html += '<div id="spec-table-pc-' + escapedTemplateId + '-' + sectionIdx + '-container" class="dc_table_container">';
          html += '<table class="dc_table" id="spec-table-pc-' + escapedTemplateId + '-' + sectionIdx + '">';
          html += '<tbody id="spec-table-pc-' + escapedTemplateId + '-' + sectionIdx + '-tbody"></tbody>';
          html += '</table>';
          html += '</div>';
          html += '</div>';
        } else {
          html += '<h3 class="dc_heading">';
          html += escapeHtml(sectionData.heading);
          html += '</h3>';
          html += '<div id="spec-table-pc-' + escapedTemplateId + '-' + sectionIdx + '-container" class="dc_table_container">';
          html += '<table class="dc_table" id="spec-table-pc-' + escapedTemplateId + '-' + sectionIdx + '">';
          html += '<tbody id="spec-table-pc-' + escapedTemplateId + '-' + sectionIdx + '-tbody"></tbody>';
          html += '</table>';
          html += '</div>';
        }
        html += '</div>';
        
        // Versiunea pentru mobile
        html += '<div class="dc_accordion_mobile_version">';
        if (showAccordionMobile) {
          html += '<div class="dc_section_header" onclick="toggleSpecSection(' + sectionIdx + ', \'' + escapedTemplateId + '\', \'mobile\')">';
          html += '<span>' + escapeHtml(sectionData.heading) + '</span>';
          html += '<span class="dc_accordion_arrow" id="spec-arrow-mobile-' + escapedTemplateId + '-' + sectionIdx + '">' + arrowDownSvg + '</span>';
          html += '</div>';
          html += '<div id="spec-section-mobile-' + escapedTemplateId + '-' + sectionIdx + '" class="dc_section_content" style="display: none;">';
          html += '<div id="spec-table-mobile-' + escapedTemplateId + '-' + sectionIdx + '-container" class="dc_table_container">';
          html += '<table class="dc_table" id="spec-table-mobile-' + escapedTemplateId + '-' + sectionIdx + '">';
          html += '<tbody id="spec-table-mobile-' + escapedTemplateId + '-' + sectionIdx + '-tbody"></tbody>';
          html += '</table>';
          html += '</div>';
          html += '</div>';
        } else {
          html += '<h3 class="dc_heading">';
          html += escapeHtml(sectionData.heading);
          html += '</h3>';
          html += '<div id="spec-table-mobile-' + escapedTemplateId + '-' + sectionIdx + '-container" class="dc_table_container">';
          html += '<table class="dc_table" id="spec-table-mobile-' + escapedTemplateId + '-' + sectionIdx + '">';
          html += '<tbody id="spec-table-mobile-' + escapedTemplateId + '-' + sectionIdx + '-tbody"></tbody>';
          html += '</table>';
          html += '</div>';
        }
        html += '</div>';
        
        html += '</div>';
        return;
      }
      
      // Generează două versiuni: una pentru PC, una pentru mobile
      html += '<div class="dc_section">';
      
      // Versiunea pentru PC
      html += '<div class="dc_accordion_pc_version">';
      if (showAccordionPC) {
        // Pe PC: accordion
        html += '<div class="dc_section_header" onclick="toggleSpecSection(' + sectionIdx + ', \'' + escapedTemplateId + '\', \'pc\')">';
        html += '<span>' + escapeHtml(sectionData.heading) + '</span>';
        html += '<span class="dc_accordion_arrow" id="spec-arrow-pc-' + escapedTemplateId + '-' + sectionIdx + '">' + arrowDownSvg + '</span>';
        html += '</div>';
        html += '<div id="spec-section-pc-' + escapedTemplateId + '-' + sectionIdx + '" class="dc_section_content" style="display: none;">';
        html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsPC, 'pc', splitViewPerMetafield);
        html += '</div>';
      } else {
        // Pe PC: normal (fără accordion)
        html += '<h3 class="dc_heading">';
        html += escapeHtml(sectionData.heading);
        html += '</h3>';
        html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsPC, 'pc', splitViewPerMetafield);
      }
      html += '</div>';
      
      // Versiunea pentru mobile
      html += '<div class="dc_accordion_mobile_version">';
      if (showAccordionMobile) {
        // Pe mobile: accordion
        html += '<div class="dc_section_header" onclick="toggleSpecSection(' + sectionIdx + ', \'' + escapedTemplateId + '\', \'mobile\')">';
        html += '<span>' + escapeHtml(sectionData.heading) + '</span>';
        html += '<span class="dc_accordion_arrow" id="spec-arrow-mobile-' + template.id + '-' + sectionIdx + '">' + arrowDownSvg + '</span>';
        html += '</div>';
        html += '<div id="spec-section-mobile-' + template.id + '-' + sectionIdx + '" class="dc_section_content" style="display: none;">';
        html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsMobile, 'mobile', splitViewPerMetafield);
        html += '</div>';
      } else {
        // Pe mobile: normal (fără accordion)
        html += '<h3 class="dc_heading">';
        html += escapeHtml(sectionData.heading);
        html += '</h3>';
        html += renderSectionTable(sectionData, styling, firstColumnWidth, false, escapedTemplateId, sectionIdx, allMetafieldsWithSection, sectionData.displayMetafieldsMobile, 'mobile', splitViewPerMetafield);
      }
      html += '</div>';
      
      html += '</div>';
    });
    }
    // Adaugă butonul "See more" pentru PC și mobile separat, dacă este necesar
    const seeMoreButtonStyle = styling.seeMoreButtonStyle || 'arrow';
    const seeMoreButtonText = styling.seeMoreButtonText || 'See More';
    const showArrow = seeMoreButtonStyle === 'arrow' || seeMoreButtonStyle === 'arrow+text';
    const showText = seeMoreButtonStyle === 'text' || seeMoreButtonStyle === 'arrow+text';
  
    if (hasMorePC || hasMoreMobile) {
      // Butonul pentru PC
      if (hasMorePC) {
        html += '<div class="dc_see_more dc_see_more_pc">';
        html += '<button class="dc_see_more_button" onclick="showAllTableRows(\'' + escapedTemplateId + '\', event, \'pc\')">';
        if (showArrow) {
          html += '<span id="see-more-arrow-pc-' + escapedTemplateId + '" class="dc_see_more_arrow">' + arrowDownSvg + '</span>';
        }
        if (showText) {
          html += '<span class="dc_see_more_text">' + escapeHtml(seeMoreButtonText) + '</span>';
        }
        html += '</button>';
        html += '</div>';
      }
      
      // Butonul pentru mobile
      if (hasMoreMobile) {
        html += '<div class="dc_see_more dc_see_more_mobile">';
        html += '<button class="dc_see_more_button" onclick="showAllTableRows(\'' + escapedTemplateId + '\', event, \'mobile\')">';
        if (showArrow) {
          html += '<span id="see-more-arrow-mobile-' + escapedTemplateId + '" class="dc_see_more_arrow">' + arrowDownSvg + '</span>';
        }
        if (showText) {
          html += '<span class="dc_see_more_text">' + escapeHtml(seeMoreButtonText) + '</span>';
        }
        html += '</button>';
        html += '</div>';
      }
      
      // Adaugă rândurile ascunse organizate pe secțiuni (ca tabele complete)
      html += '<div id="spec-table-hidden-' + escapedTemplateId + '" class="dc_hidden">';
      Object.keys(allGroupedBySection).forEach(sectionIndex => {
        const sectionIdx = parseInt(sectionIndex);
        const sectionData = allGroupedBySection[sectionIndex];
        
        // Container pentru rândurile ascunse PC
        if (sectionData.hiddenMetafieldsPC.length > 0) {
          html += '<div id="spec-hidden-section-pc-' + escapedTemplateId + '-' + sectionIdx + '" data-section-index="' + sectionIdx + '" data-device="pc">';
          html += '<table style="display: none;"><tbody>';
          html += renderHiddenRowsAsTable(sectionData.hiddenMetafieldsPC, styling, escapedTemplateId, sectionIdx, allMetafieldsWithSection);
          html += '</tbody></table>';
          html += '</div>';
        }
        
        // Container pentru rândurile ascunse mobile
        if (sectionData.hiddenMetafieldsMobile.length > 0) {
          html += '<div id="spec-hidden-section-mobile-' + escapedTemplateId + '-' + sectionIdx + '" data-section-index="' + sectionIdx + '" data-device="mobile">';
          html += '<table style="display: none;"><tbody>';
          html += renderHiddenRowsAsTable(sectionData.hiddenMetafieldsMobile, styling, escapedTemplateId, sectionIdx, allMetafieldsWithSection);
          html += '</tbody></table>';
          html += '</div>';
        }
      });
      html += '</div>';
    }
    
    html += '</div>';
    
    // Debug logging pentru split view
    if (splitViewPerSection || splitViewPerMetafield) {
      console.log('[renderTemplate] Split view enabled:', {
        splitViewPerSection: splitViewPerSection,
        splitViewPerMetafield: splitViewPerMetafield,
        sectionsToRenderCount: sectionsToRender ? sectionsToRender.length : 0,
        leftColumnCount: leftColumnSections ? leftColumnSections.length : 0,
        rightColumnCount: rightColumnSections ? rightColumnSections.length : 0,
        allGroupedBySection: Object.keys(allGroupedBySection).length
      });
    }
    
    console.log('[renderTemplate] HTML generated, length:', html.length);
    console.log('[renderTemplate] About to set innerHTML...');
    
    try {
      container.innerHTML = html;
      console.log('[renderTemplate] innerHTML set successfully!');
    } catch (error) {
      console.error('[renderTemplate] Error setting innerHTML:', error);
      console.error('[renderTemplate] Error name:', error.name);
      console.error('[renderTemplate] Error message:', error.message);
      console.error('[renderTemplate] Error stack:', error.stack);
      console.error('[renderTemplate] HTML length:', html.length);
      console.error('[renderTemplate] HTML preview (first 500 chars):', html.substring(0, 500));
      console.error('[renderTemplate] HTML preview (last 500 chars):', html.substring(Math.max(0, html.length - 500)));
      throw error;
    }
    console.log('[renderTemplate] END - Function completed');
  }
  
  function renderSectionTable(section, styling, firstColumnWidth, seeMoreEnabled, templateId, sectionIndex, allMetafieldsWithSection, displayMetafields, device, splitViewPerMetafield) {
    // Generează ID-uri unice pentru PC și mobile
    const deviceSuffix = device ? '-' + device : '';
    const tableId = 'spec-table' + deviceSuffix + '-' + templateId + '-' + sectionIndex;
    
    // Dacă splitViewPerMetafield este activat, distribuie metafields-urile în 2 coloane
    if (splitViewPerMetafield && displayMetafields.length > 0) {
      const leftColumnMetafields = [];
      const rightColumnMetafields = [];
      displayMetafields.forEach((metafield, index) => {
        if (index % 2 === 0) {
          leftColumnMetafields.push(metafield);
        } else {
          rightColumnMetafields.push(metafield);
        }
      });
      
      let html = '<div id="' + tableId + '-container" class="dc_table_container dc_split_view_metafields" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">';
      html += '<div class="dc_split_view_metafield_column dc_split_view_metafield_left">';
      html += '<table class="dc_table" id="' + tableId + '-left">';
      html += '<tbody id="' + tableId + '-tbody-left">';
      html += renderMetafieldsRows(leftColumnMetafields, styling, allMetafieldsWithSection);
      html += '</tbody></table>';
      html += '</div>';
      html += '<div class="dc_split_view_metafield_column dc_split_view_metafield_right">';
      html += '<table class="dc_table" id="' + tableId + '-right">';
      html += '<tbody id="' + tableId + '-tbody-right">';
      html += renderMetafieldsRows(rightColumnMetafields, styling, allMetafieldsWithSection);
      html += '</tbody></table>';
      html += '</div>';
      html += '</div>';
      return html;
    }
    
    // Renderizare normală (fără split view per metafield)
    let html = '<div id="' + tableId + '-container" class="dc_table_container">';
    html += '<table class="dc_table" id="' + tableId + '">';
    html += '<tbody id="' + tableId + '-tbody">';
    
    // Obține metafield-urile cu valori din obiectele construite în Liquid
    const productMetafields = window.productMetafieldsData || {};
    const variantMetafields = window.variantMetafieldsData || {};
    
    // Renderizează fiecare metafield din lista de afișat
    displayMetafields.forEach((metafield, index) => {
      // Verifică dacă metafield-ul are valoare
      let hasValue = false;
      let value = null;
      
      if (metafield.ownerType === 'PRODUCT') {
        if (productMetafields[metafield.namespace] && 
            productMetafields[metafield.namespace][metafield.key] !== undefined) {
          value = productMetafields[metafield.namespace][metafield.key];
          // Verifică dacă valoarea nu este goală, null, undefined sau "N/A"
          hasValue = value !== null && 
                    value !== undefined && 
                    value !== '' && 
                    (typeof value !== 'string' || value.trim() !== '') &&
                    value !== 'null' && 
                    value !== 'undefined' &&
                    (typeof value !== 'string' || value.trim().toUpperCase() !== 'N/A');
          
          // Pentru obiecte (product_reference, collection_reference), verifică dacă au cel puțin title sau image
          if (hasValue && typeof value === 'object') {
            hasValue = value.title || value.featured_image || value.image;
          }
        }
      } else if (metafield.ownerType === 'VARIANT') {
        // Pentru variante, verifică dacă există cel puțin o variantă cu valoare
        Object.keys(variantMetafields).forEach(variantId => {
          if (!hasValue && variantMetafields[variantId] && 
              variantMetafields[variantId][metafield.namespace] && 
              variantMetafields[variantId][metafield.namespace][metafield.key] !== undefined) {
            value = variantMetafields[variantId][metafield.namespace][metafield.key];
            hasValue = value !== null && 
                      value !== undefined && 
                      value !== '' && 
                      (typeof value !== 'string' || value.trim() !== '') &&
                      value !== 'null' && 
                      value !== 'undefined' &&
                      (typeof value !== 'string' || value.trim().toUpperCase() !== 'N/A');
            
            // Pentru obiecte, verifică dacă au cel puțin title sau image
            if (hasValue && typeof value === 'object') {
              hasValue = value.title || value.featured_image || value.image;
            }
          }
        });
      }
      
      // Calculează indexul global pentru colorarea corectă a rândurilor
      const globalIndex = allMetafieldsWithSection.indexOf(metafield);
      const isOdd = globalIndex !== -1 && globalIndex % 2 === 0;
      
      // NOUA LOGICĂ: Column background (Odd/Even) sau Row background (Odd/Even)
      // Mutual exclusivity: dacă column e activat, row nu poate fi activat și invers
      let specBackgroundStyle = '';
      let valueBackgroundStyle = '';
      if (styling.columnBackgroundEnabled) {
        // Column background: prima coloană (spec) = odd, a doua coloană (value) = even
        specBackgroundStyle = 'background-color: ' + (styling.oddColumnBackgroundColor || '#ff0000') + '; ';
        valueBackgroundStyle = 'background-color: ' + (styling.evenColumnBackgroundColor || '#00ff00') + '; ';
      } else if (styling.rowBackgroundEnabled) {
        // Row background: ambele coloane au același background bazat pe rând
        const rowBackground = isOdd ? (styling.oddRowBackgroundColor || '#f0f0f0') : (styling.evenRowBackgroundColor || '#ffffff');
        specBackgroundStyle = 'background-color: ' + rowBackground + '; ';
        valueBackgroundStyle = 'background-color: ' + rowBackground + '; ';
      } else if (styling.tdBackgroundColor && styling.tdBackgroundColor !== 'transparent') {
        // Background TD standard
        specBackgroundStyle = 'background-color: ' + styling.tdBackgroundColor + '; ';
        valueBackgroundStyle = 'background-color: ' + styling.tdBackgroundColor + '; ';
      }
      
      // Adaugă clasele pentru hide from PC/Mobile
      // Verifică dacă valorile sunt true (boolean sau string "true")
      const hideFromPC = metafield.hideFromPC === true || metafield.hideFromPC === 'true';
      const hideFromMobile = metafield.hideFromMobile === true || metafield.hideFromMobile === 'true';
      
      let rowClasses = 'dc_table_tr';
      if (hideFromPC) {
        rowClasses += ' dc_hide_from_pc';
      }
      if (hideFromMobile) {
        rowClasses += ' dc_hide_from_mobile';
      }
      
      // Dacă metafield-ul nu are valoare, adaugă clasa dc_hidden
      if (!hasValue) {
        rowClasses += ' dc_hidden';
      }
      
      // Debug logging (doar în development)
      if (hideFromPC || hideFromMobile) {
        console.log('Metafield hide flags:', {
          namespace: metafield.namespace,
          key: metafield.key,
          hideFromPC: metafield.hideFromPC,
          hideFromMobile: metafield.hideFromMobile,
          hideFromPCBool: hideFromPC,
          hideFromMobileBool: hideFromMobile,
          rowClasses: rowClasses
        });
      }
      
      html += '<tr class="' + rowClasses + '">';
      html += '<td class="dc_table_td_label"' + (specBackgroundStyle ? ' style="' + specBackgroundStyle + '"' : '') + '>';
      // Folosește customName dacă există, altfel name sau namespace.key
      const displayName = metafield.customName || metafield.name || metafield.namespace + '.' + metafield.key;
      let nameHtml = escapeHtml(displayName);
      
      // Adaugă tooltip dacă este activat
      if (metafield.tooltipEnabled && metafield.tooltipText) {
        nameHtml += ' <span class="dc_tooltip" title="' + escapeHtml(metafield.tooltipText) + '" data-tooltip-text="' + escapeHtml(metafield.tooltipText) + '" data-metafield-name="' + escapeHtml(displayName) + '">i</span>';
      }
      
      html += nameHtml + '  :';
      html += '</td>';
      html += '<td class="dc_table_td_value"' + (valueBackgroundStyle ? ' style="' + valueBackgroundStyle + '"' : '') + ' data-namespace="' + escapeHtml(metafield.namespace) + '" data-key="' + escapeHtml(metafield.key) + '" data-owner-type="' + escapeHtml(metafield.ownerType || 'PRODUCT') + '" data-type="' + escapeHtml(metafield.type || 'single_line_text_field') + '">';
      // Valoarea va fi populată din obiectul JavaScript construit în Liquid
      // Folosim un placeholder care va fi înlocuit după ce se construiește obiectul
      // IMPORTANT: Adăugăm prefix și suffix la data-attributes pentru a le putea aplica în JavaScript
      // Asigură-te că prefix și suffix sunt string-uri goale dacă sunt null sau undefined
      const prefixValue = (metafield.prefix !== null && metafield.prefix !== undefined) ? String(metafield.prefix) : '';
      const suffixValue = (metafield.suffix !== null && metafield.suffix !== undefined) ? String(metafield.suffix) : '';
      html += '<span data-metafield-value data-namespace="' + escapeHtml(metafield.namespace) + '" data-key="' + escapeHtml(metafield.key) + '" data-owner-type="' + escapeHtml(metafield.ownerType || 'PRODUCT') + '" data-type="' + escapeHtml(metafield.type || 'single_line_text_field') + '" data-prefix="' + escapeHtml(prefixValue) + '" data-suffix="' + escapeHtml(suffixValue) + '">Loading...</span>';
      html += '</td>';
      html += '</tr>';
    });
    
    html += '</tbody></table>';
    html += '</div>';
    
    return html;
  }
  
  // Funcție helper pentru a renderiza rândurile de metafields (folosită pentru split view per metafield)
  function renderMetafieldsRows(metafields, styling, allMetafieldsWithSection) {
    let rowsHtml = '';
    const productMetafields = window.productMetafieldsData || {};
    const variantMetafields = window.variantMetafieldsData || {};
    
    metafields.forEach((metafield, index) => {
      // Verifică dacă metafield-ul are valoare
      let hasValue = false;
      let value = null;
      
      if (metafield.ownerType === 'PRODUCT') {
        if (productMetafields[metafield.namespace] && 
            productMetafields[metafield.namespace][metafield.key] !== undefined) {
          value = productMetafields[metafield.namespace][metafield.key];
          hasValue = value !== null && 
                    value !== undefined && 
                    value !== '' && 
                    (typeof value !== 'string' || value.trim() !== '') &&
                    value !== 'null' && 
                    value !== 'undefined' &&
                    (typeof value !== 'string' || value.trim().toUpperCase() !== 'N/A');
          if (hasValue && typeof value === 'object') {
            hasValue = value.title || value.featured_image || value.image;
          }
        }
      } else if (metafield.ownerType === 'VARIANT') {
        Object.keys(variantMetafields).forEach(variantId => {
          if (!hasValue && variantMetafields[variantId] && 
              variantMetafields[variantId][metafield.namespace] && 
              variantMetafields[variantId][metafield.namespace][metafield.key] !== undefined) {
            value = variantMetafields[variantId][metafield.namespace][metafield.key];
            hasValue = value !== null && 
                      value !== undefined && 
                      value !== '' && 
                      (typeof value !== 'string' || value.trim() !== '') &&
                      value !== 'null' && 
                      value !== 'undefined' &&
                      (typeof value !== 'string' || value.trim().toUpperCase() !== 'N/A');
            if (hasValue && typeof value === 'object') {
              hasValue = value.title || value.featured_image || value.image;
            }
          }
        });
      }
      
      const globalIndex = allMetafieldsWithSection.indexOf(metafield);
      const isOdd = globalIndex !== -1 && globalIndex % 2 === 0;
      
      let specBackgroundStyle = '';
      let valueBackgroundStyle = '';
      if (styling.columnBackgroundEnabled) {
        specBackgroundStyle = 'background-color: ' + (styling.oddColumnBackgroundColor || '#ff0000') + '; ';
        valueBackgroundStyle = 'background-color: ' + (styling.evenColumnBackgroundColor || '#00ff00') + '; ';
      } else if (styling.rowBackgroundEnabled) {
        const rowBackground = isOdd ? (styling.oddRowBackgroundColor || '#f0f0f0') : (styling.evenRowBackgroundColor || '#ffffff');
        specBackgroundStyle = 'background-color: ' + rowBackground + '; ';
        valueBackgroundStyle = 'background-color: ' + rowBackground + '; ';
      } else if (styling.tdBackgroundColor && styling.tdBackgroundColor !== 'transparent') {
        specBackgroundStyle = 'background-color: ' + styling.tdBackgroundColor + '; ';
        valueBackgroundStyle = 'background-color: ' + styling.tdBackgroundColor + '; ';
      }
      
      const hideFromPC = metafield.hideFromPC === true || metafield.hideFromPC === 'true';
      const hideFromMobile = metafield.hideFromMobile === true || metafield.hideFromMobile === 'true';
      
      let rowClasses = 'dc_table_tr';
      if (hideFromPC) {
        rowClasses += ' dc_hide_from_pc';
      }
      if (hideFromMobile) {
        rowClasses += ' dc_hide_from_mobile';
      }
      if (!hasValue) {
        rowClasses += ' dc_hidden';
      }
      
      rowsHtml += '<tr class="' + rowClasses + '">';
      rowsHtml += '<td class="dc_table_td_label"' + (specBackgroundStyle ? ' style="' + specBackgroundStyle + '"' : '') + '>';
      const displayName = metafield.customName || metafield.name || metafield.namespace + '.' + metafield.key;
      let nameHtml = escapeHtml(displayName);
      if (metafield.tooltipEnabled && metafield.tooltipText) {
        nameHtml += ' <span class="dc_tooltip" title="' + escapeHtml(metafield.tooltipText) + '" data-tooltip-text="' + escapeHtml(metafield.tooltipText) + '" data-metafield-name="' + escapeHtml(displayName) + '">i</span>';
      }
      rowsHtml += nameHtml + '  :';
      rowsHtml += '</td>';
      const prefixValue = (metafield.prefix !== null && metafield.prefix !== undefined) ? String(metafield.prefix) : '';
      const suffixValue = (metafield.suffix !== null && metafield.suffix !== undefined) ? String(metafield.suffix) : '';
      rowsHtml += '<td class="dc_table_td_value"' + (valueBackgroundStyle ? ' style="' + valueBackgroundStyle + '"' : '') + ' data-namespace="' + escapeHtml(metafield.namespace) + '" data-key="' + escapeHtml(metafield.key) + '" data-owner-type="' + escapeHtml(metafield.ownerType || 'PRODUCT') + '" data-type="' + escapeHtml(metafield.type || 'single_line_text_field') + '">';
      rowsHtml += '<span data-metafield-value data-namespace="' + escapeHtml(metafield.namespace) + '" data-key="' + escapeHtml(metafield.key) + '" data-owner-type="' + escapeHtml(metafield.ownerType || 'PRODUCT') + '" data-type="' + escapeHtml(metafield.type || 'single_line_text_field') + '" data-prefix="' + escapeHtml(prefixValue) + '" data-suffix="' + escapeHtml(suffixValue) + '">Loading...</span>';
      rowsHtml += '</td>';
      rowsHtml += '</tr>';
    });
    
    return rowsHtml;
  }
  
  function renderHiddenRowsAsTable(metafields, styling, templateId, sectionIndex, allMetafieldsWithSection) {
    // Generează rândurile HTML pentru metafield-urile ascunse
    let rowsHtml = '';
    
    // Obține metafield-urile cu valori din obiectele construite în Liquid
    const productMetafields = window.productMetafieldsData || {};
    const variantMetafields = window.variantMetafieldsData || {};
    
    metafields.forEach((metafield, index) => {
      // Verifică dacă metafield-ul are valoare
      let hasValue = false;
      let value = null;
      
      if (metafield.ownerType === 'PRODUCT') {
        if (productMetafields[metafield.namespace] && 
            productMetafields[metafield.namespace][metafield.key] !== undefined) {
          value = productMetafields[metafield.namespace][metafield.key];
          // Verifică dacă valoarea nu este goală, null, undefined sau "N/A"
          hasValue = value !== null && 
                    value !== undefined && 
                    value !== '' && 
                    (typeof value !== 'string' || value.trim() !== '') &&
                    value !== 'null' && 
                    value !== 'undefined' &&
                    (typeof value !== 'string' || value.trim().toUpperCase() !== 'N/A');
          
          // Pentru obiecte (product_reference, collection_reference), verifică dacă au cel puțin title sau image
          if (hasValue && typeof value === 'object') {
            hasValue = value.title || value.featured_image || value.image;
          }
        }
      } else if (metafield.ownerType === 'VARIANT') {
        // Pentru variante, verifică dacă există cel puțin o variantă cu valoare
        Object.keys(variantMetafields).forEach(variantId => {
          if (!hasValue && variantMetafields[variantId] && 
              variantMetafields[variantId][metafield.namespace] && 
              variantMetafields[variantId][metafield.namespace][metafield.key] !== undefined) {
            value = variantMetafields[variantId][metafield.namespace][metafield.key];
            hasValue = value !== null && 
                      value !== undefined && 
                      value !== '' && 
                      (typeof value !== 'string' || value.trim() !== '') &&
                      value !== 'null' && 
                      value !== 'undefined' &&
                      (typeof value !== 'string' || value.trim().toUpperCase() !== 'N/A');
            
            // Pentru obiecte, verifică dacă au cel puțin title sau image
            if (hasValue && typeof value === 'object') {
              hasValue = value.title || value.featured_image || value.image;
            }
          }
        });
      }
      
      // Calculează indexul global pentru colorarea corectă a rândurilor
      const globalIndex = allMetafieldsWithSection.indexOf(metafield);
      const isOdd = globalIndex !== -1 && globalIndex % 2 === 0;
      
      // NOUA LOGICĂ: Column background (Odd/Even) sau Row background (Odd/Even)
      // Mutual exclusivity: dacă column e activat, row nu poate fi activat și invers
      let specBackgroundStyle = '';
      let valueBackgroundStyle = '';
      if (styling.columnBackgroundEnabled) {
        // Column background: prima coloană (spec) = odd, a doua coloană (value) = even
        specBackgroundStyle = 'background-color: ' + (styling.oddColumnBackgroundColor || '#ff0000') + '; ';
        valueBackgroundStyle = 'background-color: ' + (styling.evenColumnBackgroundColor || '#00ff00') + '; ';
      } else if (styling.rowBackgroundEnabled) {
        // Row background: ambele coloane au același background bazat pe rând
        const rowBackground = isOdd ? (styling.oddRowBackgroundColor || '#f0f0f0') : (styling.evenRowBackgroundColor || '#ffffff');
        specBackgroundStyle = 'background-color: ' + rowBackground + '; ';
        valueBackgroundStyle = 'background-color: ' + rowBackground + '; ';
      } else if (styling.tdBackgroundColor && styling.tdBackgroundColor !== 'transparent') {
        // Background TD standard
        specBackgroundStyle = 'background-color: ' + styling.tdBackgroundColor + '; ';
        valueBackgroundStyle = 'background-color: ' + styling.tdBackgroundColor + '; ';
      }
      
      // Adaugă clasele pentru hide from PC/Mobile
      const hideFromPC = metafield.hideFromPC === true || metafield.hideFromPC === 'true';
      const hideFromMobile = metafield.hideFromMobile === true || metafield.hideFromMobile === 'true';
      
      let rowClasses = 'dc_table_tr';
      if (hideFromPC) {
        rowClasses += ' dc_hide_from_pc';
      }
      if (hideFromMobile) {
        rowClasses += ' dc_hide_from_mobile';
      }
      
      // Dacă metafield-ul nu are valoare, adaugă clasa dc_hidden
      if (!hasValue) {
        rowClasses += ' dc_hidden';
      }
      
      rowsHtml += '<tr class="' + rowClasses + '">';
      rowsHtml += '<td class="dc_table_td_label"' + (specBackgroundStyle ? ' style="' + specBackgroundStyle + '"' : '') + '>';
      const displayName = metafield.customName || metafield.name || metafield.namespace + '.' + metafield.key;
      let nameHtml = escapeHtml(displayName);
      
      if (metafield.tooltipEnabled && metafield.tooltipText) {
        nameHtml += ' <span class="dc_tooltip" title="' + escapeHtml(metafield.tooltipText) + '" data-tooltip-text="' + escapeHtml(metafield.tooltipText) + '" data-metafield-name="' + escapeHtml(displayName) + '">i</span>';
      }
      
      rowsHtml += nameHtml + '  :';
      rowsHtml += '</td>';
      rowsHtml += '<td class="dc_table_td_value"' + (valueBackgroundStyle ? ' style="' + valueBackgroundStyle + '"' : '') + ' data-namespace="' + escapeHtml(metafield.namespace) + '" data-key="' + escapeHtml(metafield.key) + '" data-owner-type="' + escapeHtml(metafield.ownerType || 'PRODUCT') + '" data-type="' + escapeHtml(metafield.type || 'single_line_text_field') + '">';
      // Asigură-te că prefix și suffix sunt string-uri goale dacă sunt null sau undefined
      const prefixValue = (metafield.prefix !== null && metafield.prefix !== undefined) ? String(metafield.prefix) : '';
      const suffixValue = (metafield.suffix !== null && metafield.suffix !== undefined) ? String(metafield.suffix) : '';
      rowsHtml += '<span data-metafield-value data-namespace="' + escapeHtml(metafield.namespace) + '" data-key="' + escapeHtml(metafield.key) + '" data-owner-type="' + escapeHtml(metafield.ownerType || 'PRODUCT') + '" data-type="' + escapeHtml(metafield.type || 'single_line_text_field') + '" data-prefix="' + escapeHtml(prefixValue) + '" data-suffix="' + escapeHtml(suffixValue) + '">Loading...</span>';
      rowsHtml += '</td>';
      rowsHtml += '</tr>';
    });
    
    // Returnează doar rândurile (fără tabel), pentru a le adăuga în tabelul existent
    return rowsHtml;
  }
  
  window.showAllTableRows = function(templateId, event, device) {
    // Previne comportamentul implicit
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    
    const hiddenContainer = document.getElementById('spec-table-hidden-' + templateId);
    if (!hiddenContainer) {
      console.log('Hidden container not found:', 'spec-table-hidden-' + templateId);
      return;
    }
    
    // Găsește toate containerele cu rânduri ascunse pentru device-ul specificat
    const selector = '[id^="spec-hidden-section-' + device + '-' + templateId + '-"]';
    const hiddenSections = hiddenContainer.querySelectorAll(selector);
    
    console.log('Found hidden sections for device', device, ':', hiddenSections.length);
    
    hiddenSections.forEach(sectionContainer => {
      const sectionIndex = sectionContainer.getAttribute('data-section-index');
      const tableId = 'spec-table-' + device + '-' + templateId + '-' + sectionIndex;
      
      // Găsește containerul corespunzător device-ului (PC sau mobile)
      // Încearcă mai întâi în versiunea seeMore
      const seeMoreVersionClass = device === 'pc' ? 'dc_see_more_pc_version' : 'dc_see_more_mobile_version';
      let deviceContainer = document.querySelector('.' + seeMoreVersionClass + ' #' + tableId + '-container');
      
      // Dacă nu găsește, încearcă în versiunea accordion
      if (!deviceContainer) {
        const accordionVersionClass = device === 'pc' ? 'dc_accordion_pc_version' : 'dc_accordion_mobile_version';
        deviceContainer = document.querySelector('.' + accordionVersionClass + ' #' + tableId + '-container');
      }
      
      if (!deviceContainer) {
        console.log('Device container not found for', device, 'tableId:', tableId);
        return;
      }
      
      const tbody = deviceContainer.querySelector('#' + tableId + '-tbody');
      
      if (!tbody) {
        console.log('Tbody not found for', device, 'tableId:', tableId);
        return;
      }
      
      // Găsește tabelul temporar din containerul ascuns
      const tempTable = sectionContainer.querySelector('table');
      if (tempTable) {
        const tempTbody = tempTable.querySelector('tbody');
        if (tempTbody) {
          // Mută toate rândurile din tbody-ul temporar în tbody-ul tabelului existent
          const rows = Array.from(tempTbody.querySelectorAll('tr'));
          console.log('Moving', rows.length, 'rows to', device, 'tableId:', tableId);
          rows.forEach(row => {
            tbody.appendChild(row);
          });
        }
      }
    });
    
    // Ascunde butonul "See more" pentru device-ul specificat
    const button = event ? event.target.closest('button') : document.querySelector('.dc_see_more_' + device + ' .dc_see_more_button');
    if (button) {
      button.style.display = 'none';
    }
    
    // Rotirește săgeata pentru device-ul specificat
    const arrow = document.getElementById('see-more-arrow-' + device + '-' + templateId);
    if (arrow) {
      arrow.style.transform = 'rotate(180deg)';
    }
    
    // Actualizează valorile metafield-urilor pentru rândurile nou afișate (inclusiv prefix și suffix)
    const container = document.getElementById('specification-table-container-' + templateId);
    if (container) {
      updateMetafieldValuesFromLiquid(container);
    }
  };
  
  // Funcție globală pentru toggle accordion
  window.toggleSpecSection = function(sectionIndex, templateId, device) {
    // Dacă device nu este specificat, încercă să-l detecteze sau folosește versiunea veche pentru compatibilitate
    if (!device) {
      // Versiunea veche (fără device) - pentru compatibilitate
      const section = document.getElementById('spec-section-' + templateId + '-' + sectionIndex);
      const arrow = document.getElementById('spec-arrow-' + templateId + '-' + sectionIndex);
      if (section) {
        const isHidden = section.style.display === 'none' || section.style.display === '';
        section.style.display = isHidden ? 'block' : 'none';
        if (arrow) {
          arrow.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
        }
      }
      return;
    }
    
    // Versiunea nouă cu device
    const section = document.getElementById('spec-section-' + device + '-' + templateId + '-' + sectionIndex);
    const arrow = document.getElementById('spec-arrow-' + device + '-' + templateId + '-' + sectionIndex);
    if (section) {
      const isHidden = section.style.display === 'none' || section.style.display === '';
      section.style.display = isHidden ? 'block' : 'none';
      if (arrow) {
        arrow.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
      }
    }
  };
  
  // Funcție pentru afișarea tooltip-ului pe mobil (click)
  function showTooltipOnMobile(tooltipText, metafieldName, event) {
    // Creează overlay-ul
    const overlay = document.createElement('div');
    overlay.className = 'dc_tooltip_overlay';
    overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
    
    // Creează popup-ul
    const popup = document.createElement('div');
    popup.className = 'dc_tooltip_popup';
    popup.style.cssText = 'background-color: #ffffff; border-radius: 8px; padding: 20px; max-width: 90%; max-height: 80%; overflow-y: auto; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); position: relative;';
    
    // Adaugă numele metafield-ului sus în mijloc, urmat de ":"
    const nameElement = document.createElement('div');
    nameElement.style.cssText = 'text-align: center; font-weight: bold; font-size: 16px; color: #202223; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #e1e3e5;';
    nameElement.textContent = metafieldName + ':';
    popup.appendChild(nameElement);
    
    // Adaugă textul tooltip-ului (explicația)
    const textElement = document.createElement('div');
    textElement.style.cssText = 'color: #202223; font-size: 14px; line-height: 1.5;';
    textElement.textContent = tooltipText;
    popup.appendChild(textElement);
    
    // Adaugă butonul de închidere
    const closeButton = document.createElement('button');
    closeButton.textContent = '×';
    closeButton.style.cssText = 'position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; color: #6d7175; cursor: pointer; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; padding: 0;';
    closeButton.onclick = function() {
      document.body.removeChild(overlay);
    };
    popup.appendChild(closeButton);
    
    overlay.appendChild(popup);
    document.body.appendChild(overlay);
    
    // Închide popup-ul când se dă click pe overlay
    overlay.onclick = function(e) {
      if (e.target === overlay) {
        document.body.removeChild(overlay);
      }
    };
    
    // Previne propagarea evenimentului
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  
  // Adaugă event listener pentru click pe tooltip pe mobil
  document.addEventListener('click', function(event) {
    const tooltip = event.target.closest('.dc_tooltip');
    if (tooltip) {
      // Verifică dacă este pe mobil (touch device sau ecran mic)
      const isMobile = 'ontouchstart' in window || window.innerWidth <= 768;
      if (isMobile) {
        const tooltipText = tooltip.getAttribute('data-tooltip-text') || tooltip.getAttribute('title');
        const metafieldName = tooltip.getAttribute('data-metafield-name') || '';
        if (tooltipText) {
          showTooltipOnMobile(tooltipText, metafieldName, event);
        }
      }
    }
  });
  
  // După ce template-ul este renderat, obține metafield-urile din Liquid
  // Aceasta este o limitare - trebuie să obții metafield-urile din Liquid și să le pasezi la JavaScript
})();
</script>
{% endif %}

{% schema %}
{
  "name": "SmartSpecs Table",
  "target": "section",
  "settings": [

    {
      "type": "range",
      "id": "max_width",
      "label": "Max Width",
      "min": 100,
      "max": 2000,
      "step": 100,
      "unit": "px",
      "default": 1200
    },
    {
      "type": "select",
      "id": "alignment",
      "label": "Align",
      "options": [
        {
          "value": "left",
          "label": "Left"
        },
        {
          "value": "center",
          "label": "Center"
        },
        {
          "value": "right",
          "label": "Right"
        }
      ],
      "default": "left"
    },
    {
      "type": "range",
      "id": "first_column_width",
      "label": "First column width",
      "min": 10,
      "max": 90,
      "step": 10,
      "unit": "%",
      "default": 40
    },
    {
      "type": "range",
      "id": "margin_top",
      "label": "Top Gap",
      "min": 0,
      "max": 200,
      "step": 10,
      "unit": "px",
      "default": 0
    },
    {
      "type": "range",
      "id": "margin_left",
      "label": "Left Gap",
      "min": 0,
      "max": 200,
      "step": 10,
      "unit": "px",
      "default": 0
    },
    {
      "type": "range",
      "id": "image_height",
      "label": "Image Height",
      "min": 40,
      "max": 300,
      "step": 20,
      "unit": "px",
      "default": 100
    }
  ]
}
{% endschema %}