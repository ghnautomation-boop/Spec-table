# Ghid PostgreSQL pentru Scalabilitate

## 1. Soluții PostgreSQL Recomandate

### Opțiuni Managed (Recomandate pentru producție)

#### **Neon** (Recomandat pentru început)
- **Preț**: Free tier generos (0.5GB storage, 1GB RAM)
- **Scaling**: Pay-as-you-go
- **Features**: Serverless, branching, auto-scaling
- **Link**: https://neon.tech
- **Perfect pentru**: Startups, scale rapid

#### **Supabase** (Recomandat pentru full-stack)
- **Preț**: Free tier (500MB database, 2GB bandwidth)
- **Scaling**: $25/mo pentru 8GB RAM
- **Features**: PostgreSQL + Auth + Storage + Realtime
- **Link**: https://supabase.com
- **Perfect pentru**: Aplicații care au nevoie de mai multe servicii

#### **Railway** (Simplu și rapid)
- **Preț**: $5/mo pentru 1GB RAM
- **Scaling**: Pay-as-you-go
- **Features**: Deploy simplu, auto-scaling
- **Link**: https://railway.app
- **Perfect pentru**: Deploy rapid

#### **DigitalOcean Managed Databases**
- **Preț**: $15/mo pentru 1GB RAM, 10GB storage
- **Scaling**: Vertical scaling ușor
- **Features**: Backups automate, monitoring
- **Link**: https://www.digitalocean.com/products/managed-databases
- **Perfect pentru**: Producție stabilă

#### **AWS RDS PostgreSQL**
- **Preț**: ~$15-30/mo pentru db.t3.micro
- **Scaling**: Horizontal și vertical
- **Features**: Enterprise-grade, high availability
- **Link**: https://aws.amazon.com/rds/postgresql/
- **Perfect pentru**: Scale enterprise

#### **PlanetScale** (MySQL, dar similar)
- **Preț**: Free tier generos
- **Scaling**: Serverless, auto-scaling
- **Link**: https://planetscale.com
- **Notă**: MySQL, nu PostgreSQL, dar foarte bun pentru scale

### Recomandare Finală
**Pentru început**: **Neon** (free tier generos, serverless)
**Pentru producție**: **DigitalOcean** sau **AWS RDS** (stabilitate)

---

## 2. Migrare de la SQLite la PostgreSQL

### Pas 1: Actualizează `prisma/schema.prisma`

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

### Pas 2: Setează variabila de mediu

```bash
# .env
DATABASE_URL="postgresql://user:password@host:5432/database?schema=public"
```

### Pas 3: Generează migrația

```bash
npx prisma migrate dev --name migrate_to_postgresql
```

### Pas 4: Migrează datele (dacă ai date existente)

```bash
# Export din SQLite
sqlite3 dev.sqlite .dump > backup.sql

# Convert și import în PostgreSQL (folosește un tool de conversie)
```

---

## 3. Indexuri Necesare pentru Optimizare

### Indexuri Critice (Adaugă în schema.prisma)

```prisma
model TemplateAssignment {
  // ... existing fields ...
  
  // Index compus pentru query-uri frecvente
  @@index([shopId, assignmentType])
  @@index([shopId, templateId, assignmentType])
}

model TemplateAssignmentTarget {
  // ... existing fields ...
  
  // Index compus pentru lookup rapid
  @@index([assignmentId, targetShopifyId, isExcluded])
  @@index([targetShopifyId, targetType])
}

model SpecificationTemplate {
  // ... existing fields ...
  
  // Index pentru query-uri active
  @@index([shopId, isActive])
}

model TemplateSectionMetafield {
  // ... existing fields ...
  
  // Index pentru ordering
  @@index([sectionId, order])
}
```

---

## 4. Optimizări Query-uri

### Problema Actuală
`getTemplateForTarget` face un query mare cu toate assignment-urile și filtrează în memorie.

### Soluție: Query-uri Optimizate

Trebuie să refactorizezi `getTemplateForTarget` să facă query-uri specifice în loc de un query mare.

---

## 5. Strategie Cache

### Cache Redis Recomandat

**Opțiuni**:
- **Upstash Redis** (Serverless, free tier generos): https://upstash.com
- **Redis Cloud** (Free tier 30MB): https://redis.com/cloud
- **Railway Redis** ($5/mo): https://railway.app

### Ce să cache-ui:
1. Template-uri complete (TTL: 5-15 min)
2. Assignment mappings (TTL: 10 min)
3. Metafield definitions (TTL: 30 min)

---

## 6. Monitoring și Performance

### Tools Recomandate:
- **Prisma Studio**: `npx prisma studio` (pentru debugging)
- **pgAdmin**: Pentru PostgreSQL management
- **New Relic** sau **Datadog**: Pentru monitoring producție

